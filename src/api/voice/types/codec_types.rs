/// Перечисление типов кодеков, которые могут использоваться в WebRTC
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodecType {
    Unknown = -1,
    Opus = 0,
    VP8 = 1,
    VP9 = 2,
    H264 = 3,
}

impl From<i32> for CodecType {
    fn from(value: i32) -> Self {
        match value {
            0 => CodecType::Opus,
            1 => CodecType::VP8,
            2 => CodecType::VP9,
            3 => CodecType::H264,
            _ => CodecType::Unknown,
        }
    }
}

/// Функция для определения смещения для шифрования VP8
///
/// VP8 фреймы оставляют 1 или 10 байт незашифрованными, в зависимости от того,
/// является ли входящий фрейм ключевым или нет.
///
/// См. https://datatracker.ietf.org/doc/html/rfc7741#section-4.3
///
/// Если P = 0, это ключевой кадр, и мы оставляем 10 байтов незашифрованными
/// для покрытия полного несжатого заголовка VP8.
///
/// Если P = 1, это не ключевой кадр, и мы оставляем только 1 байт незашифрованным
/// (только заголовок полезной нагрузки).
pub fn get_vp8_encryption_offset(data: &[u8]) -> usize {
    if data.is_empty() {
        return 0;
    }

    // Флаг P - это последний бит первого байта
    // P=0 означает, что это ключевой кадр
    let p_flag = data[0] & 0x01 != 0;

    // Используем значение из данных, а не параметр is_key_frame для большей надежности
    if !p_flag {
        // Ключевой кадр: оставляем 10 байтов незашифрованными
        10.min(data.len())
    } else {
        // Не ключевой кадр: оставляем 1 байт незашифрованным
        1.min(data.len())
    }
}
